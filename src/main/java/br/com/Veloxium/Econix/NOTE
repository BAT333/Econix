ponto chave na arquitetura em microServiços,
vamos supor que nos tem varios micro serviço separado
nem back end e nem front pode saber todos esse endereço para saber todos esse endereço
para isso usa service discorver, ele vai ter toda instancias endereço de todos micros serviço que tem la


 para fazer isso vamo usar
 Spring cloud Netflix,


   <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>

 para criar pelo spring initilizr


EUREKA SERVE


no application.properties vamos configura tudo nele do service
para tudo no serviço de descoberta recomendado que ele tenha uma porta fixa
server.port=8081



vamos fazer add duas dependecia, por que projeto pode atuar tanto quanto servidor
quanto projeto
mas vamos criar como um server so como isso
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

como trocou endereço para 8081, tem dizer como vai ser url
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka


server.port=8081

spring.application.name=server
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka


# Configurações de Aplicação
spring.application.name=eureka-server
server.port=8761

# Configurações do Eureka Server
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.server.enable-self-preservation=false
eureka.server.enable-ssl=false

# Configuração Swagger UI (opcional)
springdoc.api-docs.enabled=false
springdoc.swagger-ui.enabled=false
Explicação das Propriedades
spring.application.name=eureka-server: Define o nome da aplicação como "eureka-server".
server.port=8761: Define a porta onde o Eureka Server será acessível.
eureka.client.register-with-eureka=false: Impede que o Eureka Server se registre em si mesmo (não necessário para o Eureka Server).
eureka.client.fetch-registry=false: Impede que o Eureka Server busque o registro de outros serviços (não necessário para o Eureka Server).
eureka.server.enable-self-preservation=false: Desativa a preservação automática para evitar que o Eureka Server se torne inativo.
eureka.server.enable-ssl=false: Desativa SSL para a comunicação do Eureka Server (se SSL não for necessário).
springdoc.api-docs.enabled=false: Desativa a geração de documentação OpenAPI.
springdoc.swagger-ui.enabled=false: Desativa a interface Swagger UI (não necessária para o Eureka Server).




Propriedades
eureka.client.serviceUrl.defaultZone

Propósito: Define o endereço URL do servidor Eureka onde o cliente irá se registrar e buscar informações sobre outros serviços.
Uso: Especifica a URL do servidor Eureka para o cliente Eureka. No caso de múltiplos servidores Eureka, você pode listar várias URLs separadas por vírgulas.
Exemplo: eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.prefer-ip-address

Propósito: Indica se o cliente deve registrar seu IP em vez do nome do host.
Uso: Define se o Eureka Server deve preferir o IP da instância em vez do nome do host ao registrar o serviço. Isso é útil em ambientes onde a resolução de DNS pode não funcionar ou não é desejada.
Exemplo: eureka.instance.prefer-ip-address=true
eureka.instance.hostname

Propósito: Define o nome do host da instância que será registrado no servidor Eureka.
Uso: Define o nome do host que será usado para a instância do serviço ao se registrar no Eureka Server. Se eureka.instance.prefer-ip-address estiver definido como true, isso pode ser ignorado.
Exemplo: eureka.instance.hostname=localhost
-----------------------------------------------------------------------------------------------------------------------
@EnableEurekaServer
isso vc coloca no Application para indicar que vc vai trabalhar com EurekaServer e que é serve



------------------------------------------------------------------------------------------------------------------------------------------
AGORA VC TEM QUE ARRUMAR OUTRO LADO PARA QUE COMUNIQUE COM SERVER, MOSTRA PARA SERVI CLIENTES DELE AS APLICAÇÃO QUE VAI ESTA
PARA MICRO SERVIÇOS
PRIMEIRO DE TUDO VC TEM ADD ESSA DEPENDENCIA

<spring-cloud.version>2022.0.3</spring-cloud.version>

<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
--------------------------------------------------------------------------------------------------------------------------------------------------
QUE NO FINAL FICARA ASSIM

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.3.0</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.Veloxium</groupId>
	<artifactId>Econix</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>Econix</name>
	<description>MS de pagamento da Veloxium</description>
	<properties>
		<java.version>21</java.version>
		<spring-cloud.version>2022.0.3</spring-cloud.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-mysql</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
---------------------------------------------------------------------------------------------------------
E NO APPLICATION NO LADO DO CLIENTE USA ESSA APLICAÇÃO NA CLASS PRINCIPAL DE RODAR
@EnableDiscoveryClient
--------------------------------------------------------------------------------------------------------------------------
AGORA AINDA DO LADO CLIENT, NO APPLICATION.PROPERTIES VAMOS CONFIGURA
PRIMEIRO DE UM NOME
spring.application.name=Econix

DEPOIS A URL DEFAULTZONE POR QUE VAI SER AI QUE VAI RECEBER REQUISUÇÃO
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka
MESMA DO EUREKA

#eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka
#server.port=0
#eureka.instance.prefer-ip-address=true
#eureka.instance.hostname=localhost

POR FIM VAMOS DEIXA EURECA MESMO DECIDIR A PORTA QUE ELE VAI USAR DETE JEITO
server.port=0.
-------------------------------------------------------------------------------------------------------------
 Incluindo o Gateway
 para que serve isso, sere para centralizar serviço e endponit, um ponto unico de entrada de url

"Gateway - Spring Cloud Routing" e "Eureka Discovery Client - Spring Cloud Discovery".

 <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway-mvc</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

CONFIGURAÇÃO
APPLICATION.PROPERTIES

spring.application.name=Gateway
server.port=8082
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka

OQ DE FATO VAI AJUDAR FAZER A DESCOBRERTA FUNCIONAR VAI SER ESSE DOIS COMANDOS

spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true


E ULTIMO É QUE URL VAI TAR TUDO EM LOWERCASE


E NO APPLICATIONS TEM COLOCAR
@EnableDiscoveryClient

como chamar
localhost:8082/nomedomicroserviço/oqvcquerfazerele
ex
http://localhost:8082/gateway/econix/pay
tem usar nome da aplixação gateway




OBS USAR PADRÃO spring-cloud-starter-gateway  -> NA DEPEDENCIA
NÃO O spring-cloud-starter-gateway-MVC QUE ESTA DANDO ERRO
------------------------------------------------------------------------------------------------------------------------------------
BALECEAMENTO DE CARGA

BASTA ADD ISSO
eureka.instance.instance-id=${spring.application.name}:${random.int}
VAI ADD UMA INSTANCIA NOVA
PARA FAZER RODAR OUTRAS RUN BASTA
ADD
& "c:\alura-food\pedidos\mvnw.cmd" spring-boot:run -f "c:\alura-food\pedidos\pom.xml"
NOME QUE TA NA PASTA PMDE ESTA PASSANDO ATE CHAGAR NO POM
CAMINHO QUE ESTA APLICAÇÃO
---------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Feign
para fazer a comunicação de ms para outro micro serviço
primeiro de tudo add essa notação
@EnableFeignClients
no serviço que vc quer vire cliente que que ajuntar com outro micro serviço

e depois essa dependencia
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>



como faz para usar
primeiro cria uma interface que vai usar, por que isso não nada a mais que uma
requisção

e add anotação encima dele de

@FeignClient("")
add nome dele, que é exatamente nome que vc deu para seu micro Serviço


@FeignClient("Econix")


depois request que vc quer fazer


@RequestMapping(method = RequestMethod.PUT, value = "/pay/status/{id}");


passar url que vc quer acessar


E ONDE ULTILIZAR ISSO
na service aonde vc esta ultilizando
ex:
vc faz essa configuração no restaurante para ele ter como pago realizado, e pagamento ms diferente
ai vc vai configura o feign no restaurante e vai ultilizartudo no service do restaurante
ai se chama essa inteface na sua service ou controller, q de resto vai fazer tudo sozinho

e pode retorna coisas caso se precise
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Circuit breaker e fallback

colocando a dependencia
<!-- https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-spring-boot2 -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <version>2.2.0</version>
</dependency>


e outra


<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
    <version>3.3.0</version>
</dependency>

TUDO ISSO NO CONTROLLER

circuit
serve para quando uma parte do ms esta fora do ar para fechar ele ou tomar a devida descição para colocar ele no ar
novamente etc

oq precisa fazer, no controlador na pasta http

@CircuitBreaker()

de nome para ele
e oq ele vai fazer caso de eerro
@CircuitBreaker(name = "nomeColocado", fallbackMethod = "")

e no applications.properies configura para fazer tal situação

ESSE QUE VAI PASSAR PARA ABERTO OU FECHADO CIRCUIT BASEADO NAS ULTIMAS REQUISIÇÃO
resilience4j.circuitbreaker.instances.nomeColocado.slidingWindowSize: 3

MINIMO DE CHAMADA QUE ELE PRECISA FAZER ATE ENTRA EM FECHAMANETO ETC
resilience4j.circuitbreaker.instances.nomeColocado.minimumNumberOfCalls: 2

UMA VEZ QUE PASSOU PARA ELE PARA ABERTO, QUANTO TEMPO VAI MANTER ABERTO
resilience4j.circuitbreaker.instances.nomeColocado.waitDurationInOpenState: 50s


OQ VAI FAZER SE DEU ERRO
@CircuitBreaker(name = "nomeColocado", fallbackMethod = "OQFAZER")

ESSE METODO TEM TER MESMO NOME MESMO TIPO DE RETORNO, E MESMO PARAMENTROS, E EXCEPRIO E APENA UM PARAMETRO ADD

public void OQFAZER(Long id , Exception e){
this.service -> logica dentro chama sem chamado com integração
}

























Comunicação assíncrona é aquela que não acontece em tempo real. O emissor envia a mensagem e o receptor
pode acessá-la e respondê-la quando desejar. O modelo é mais conveniente para quem recebe, porém requer
objetividade, já que não é possível tirar dúvidas no mesmo momento.




Comunicação síncrona é aquela em que as pessoas interagem em tempo real,
envolvidos na troca simultaneamente. Já na assíncrona, as respostas não são
imediatas, sendo enviadas e recebidas em momentos diferentes


-----------------------------------------------------------------------------------------------------------------------------------

Essas configurações são usadas para habilitar e configurar o SpringDoc OpenAPI no seu aplicativo Spring Boot, permitindo que você acesse a documentação da API e a interface Swagger UI diretamente do seu serviço. Vamos detalhar cada uma:

1. springdoc.api-docs.enabled=true
Objetivo: Esta configuração ativa a geração do documento OpenAPI (Swagger) JSON que descreve a sua API.
Uso: Quando habilitado, o SpringDoc cria um endpoint /v3/api-docs (ou outro configurado) que fornece a especificação OpenAPI em formato JSON. Esse endpoint é usado por ferramentas como Swagger UI para exibir a documentação da API.
2. springdoc.swagger-ui.enabled=true
Objetivo: Esta configuração ativa a interface Swagger UI que permite visualizar e interagir com a documentação da API de forma gráfica.
Uso: Quando habilitado, o SpringDoc disponibiliza o Swagger UI na URL configurada, permitindo que você visualize a documentação da sua API e teste os endpoints diretamente a partir do navegador.
3. springdoc.swagger-ui.path=/swagger-ui.html
Objetivo: Define o caminho onde a interface Swagger UI estará disponível.
Uso: Por padrão, o Swagger UI é acessível através de /swagger-ui.html. Se você quiser configurar um caminho diferente para o Swagger UI, pode ajustar esta propriedade.
Exemplo de Configuração Completa em application.properties
Aqui está como essas configurações podem ser adicionadas ao seu application.properties para habilitar o Swagger UI e a documentação OpenAPI no seu serviço:

properties
Copiar código
# Habilitar a geração do documento OpenAPI
springdoc.api-docs.enabled=true

# Habilitar a interface Swagger UI
springdoc.swagger-ui.enabled=true

# Caminho para acessar a Swagger UI
springdoc.swagger-ui.path=/swagger-ui.html





package br.com.Gateway;

import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration

public class GatewaySwaggerConfig {
    @Bean
    public GroupedOpenApi employeeServiceApi() {
        return GroupedOpenApi.builder()
                .group("employee-service")
                .pathsToMatch("/employee/**")
                .build();
    }
}
	<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
			<version>2.5.0</version>
		</dependency>

----------------------------------------------------
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
para que serve

O ChatGPT disse:
ChatGPT
As propriedades eureka.client.register-with-eureka e eureka.client.fetch-registry são usadas para configurar como um cliente Spring Cloud (como um microserviço ou gateway) interage com o Eureka Server para o serviço de descoberta. Vamos detalhar o propósito de cada uma delas:

1. eureka.client.register-with-eureka=true
Propósito:
Essa propriedade indica se o cliente (por exemplo, um microserviço ou gateway) deve se registrar no Eureka Server como um serviço.

Quando configurado como true: O cliente se registra no Eureka Server, o que significa que ele informa ao Eureka Server que está disponível e pronto para receber solicitações. Isso é útil para outros serviços que possam precisar descobrir e se comunicar com ele.

Quando configurado como false: O cliente não se registra no Eureka Server. Isso é útil em situações onde o serviço está apenas consumindo informações de outros serviços e não precisa ser descoberto.

Exemplo de Uso:
No caso de um API Gateway ou um microserviço, você normalmente deseja que ele se registre no Eureka Server para que outros serviços possam descobrir e se comunicar com ele.

2. eureka.client.fetch-registry=true
Propósito:
Essa propriedade define se o cliente deve buscar (fazer fetch) do registro de serviços do Eureka Server. O registro de serviços é uma lista de todos os serviços atualmente registrados no Eureka Server.

Quando configurado como true: O cliente busca o registro de serviços do Eureka Server, permitindo que ele descubra e se comunique com outros serviços registrados. Isso é essencial para microserviços que precisam interagir uns com os outros ou para um gateway que precisa rotear solicitações para os serviços backend.

Quando configurado como false: O cliente não busca o registro de serviços. Isso é útil para situações onde o serviço não precisa descobrir outros serviços, como quando um serviço está sendo usado apenas para administração ou monitoramento.

Exemplo de Uso:
Para um API Gateway, fetch-registry deve ser true para que ele possa descobrir e rotear solicitações para outros microserviços registrados no Eureka Server.

Resumo
eureka.client.register-with-eureka=true: Registra o cliente no Eureka Server para que outros serviços possam descobri-lo.
eureka.client.fetch-registry=true: Permite que o cliente busque o registro de serviços do Eureka Server para descobrir outros serviços.
Em um ambiente típico de microserviços usando Spring Cloud Netflix Eureka, você geralmente configura ambos como true para permitir a descoberta mútua e a comunicação entre os serviços.

-----------------------------------------------
A configuração que você forneceu para o Gateway em um ambiente de microserviços com Spring Cloud Gateway e Eureka é bastante detalhada e cobre várias áreas importantes. Vamos analisar cada parte para entender o que faz:

1. Configurações de Aplicação
properties
Copiar código
spring.application.name=gateway
server.port=8082
spring.application.name: Define o nome do aplicativo, neste caso, "gateway". Esse nome é utilizado no registro do serviço com o Eureka e para identificação geral do serviço.
server.port: Define a porta na qual o gateway estará ouvindo. Aqui, ele está configurado para ouvir na porta 8082.
2. Configurações do Eureka Client
properties
Copiar código
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.serviceUrl.defaultZone: Configura a URL do servidor Eureka onde o cliente deve se registrar. Aqui, está configurado para um servidor Eureka em execução localmente na porta 8081.

eureka.instance.prefer-ip-address=true: Quando definido como true, isso faz com que o serviço prefira usar seu endereço IP em vez do nome do host ao se registrar no Eureka. Isso é útil em ambientes onde o DNS pode não estar configurado corretamente.

eureka.instance.hostname=localhost: Define o hostname da instância. Para ambientes locais, isso é frequentemente configurado como localhost.

eureka.client.register-with-eureka=true: Informa ao cliente Eureka para registrar o próprio gateway no servidor Eureka para que outros serviços possam descobri-lo.

eureka.client.fetch-registry=true: Configura o cliente para buscar o registro de outros serviços do servidor Eureka, permitindo que o gateway descubra outros serviços registrados.

3. Configurações do Gateway para os Microserviços
properties
Copiar código
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true
spring.cloud.gateway.discovery.locator.enabled=true: Ativa o Discovery Locator, permitindo que o gateway automaticamente configure rotas para todos os serviços registrados no Eureka. Isso simplifica muito a configuração do gateway, pois as rotas são automaticamente criadas com base nos serviços descobertos.

spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true: Faz com que todos os IDs dos serviços sejam convertidos para minúsculas. Isso é útil para evitar problemas de correspondência de caso sensível em ambientes onde os IDs de serviço podem não ser consistentes.

4. Configurações de Swagger e OpenAPI
properties
Copiar código
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.enabled=true: Habilita a geração de documentação OpenAPI para o serviço, essencial para fornecer informações sobre os endpoints disponíveis.

springdoc.swagger-ui.enabled=true: Ativa a interface Swagger UI, que é uma ferramenta interativa para explorar e testar APIs RESTful.

springdoc.swagger-ui.path=/swagger-ui.html: Define o caminho onde o Swagger UI estará acessível no gateway, neste caso, /swagger-ui.html.

5. Rotas para Microserviços
As rotas são configuradas para que o gateway saiba como rotear solicitações para os diferentes microserviços. Aqui está a configuração para o Employee Service:

properties
Copiar código
# Employee Service
spring.cloud.gateway.routes[0].id=employee-service
spring.cloud.gateway.routes[0].uri=lb://employee
spring.cloud.gateway.routes[0].predicates[0]=Path=/employee/**, /v3/api-docs/employee-service/**, /swagger-ui/**, /swagger-ui.html
spring.cloud.gateway.routes[0].filters[0]=RewritePath=/v3/api-docs/employee-service(?<segment>.*), /v3/api-docs${segment}
spring.cloud.gateway.routes[0].filters[1]=RewritePath=/swagger-ui(?<segment>.*), /swagger-ui${segment}
spring.cloud.gateway.routes[0].filters[2]=RewritePath=/swagger-ui.html(?<segment>.*), /swagger-ui.html${segment}
spring.cloud.gateway.routes[0].id=employee-service: Define o identificador único para a rota. Neste caso, o identificador é "employee-service".

spring.cloud.gateway.routes[0].uri=lb://employee: Define o URI de destino usando o esquema lb://, que indica ao gateway para usar o balanceamento de carga (load balancing) através do Eureka para o serviço "employee". Isso significa que todas as requisições que correspondam aos padrões abaixo serão roteadas para o serviço de empregado (employee).

spring.cloud.gateway.routes[0].predicates[0]=Path=/employee/**, /v3/api-docs/employee-service/**, /swagger-ui/**, /swagger-ui.html: Define os predicados da rota, ou seja, as condições que as solicitações devem atender para serem roteadas por esta rota. Aqui, todas as requisições para caminhos que começam com /employee/**, /v3/api-docs/employee-service/**, /swagger-ui/** ou /swagger-ui.html serão roteadas para o serviço "employee".

spring.cloud.gateway.routes[0].filters: Define filtros de rota. Neste exemplo, os filtros RewritePath são usados para reescrever o caminho das URLs da documentação OpenAPI e Swagger UI:

spring.cloud.gateway.routes[0].filters[0]=RewritePath=/v3/api-docs/employee-service(?<segment>.*), /v3/api-docs${segment}: Este filtro reescreve a rota /v3/api-docs/employee-service para /v3/api-docs, mantendo o segmento subsequente. Isso permite que a documentação OpenAPI do serviço "employee" seja corretamente exibida no Swagger UI do gateway.

spring.cloud.gateway.routes[0].filters[1] e spring.cloud.gateway.routes[0].filters[2]: De forma similar, esses filtros reescrevem as rotas relacionadas ao Swagger UI para garantir que a interface do Swagger seja corretamente exibida quando acessada através do gateway.

Resumo
Eureka Client: Registra o gateway com o servidor Eureka e permite que ele descubra outros serviços.
Discovery Locator: Automatiza a criação de rotas no gateway para serviços descobertos.
Swagger/OpenAPI: Ativa e configura a documentação interativa das APIs.
Rotas de Gateway: Define como as requisições devem ser roteadas do gateway para os microserviços, incluindo reescrita de caminhos para compatibilidade com documentação OpenAPI.
Essas configurações permitem que o gateway funcione como um ponto central de entrada para sua arquitetura de microserviços, roteando solicitações e fornecendo documentação API integrada para os serviços backend.










https://spring.io/ TODA DOCUMENTAÇÕES DO SPRING BOOT