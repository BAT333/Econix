ponto chave na arquitetura em microServiços,
vamos supor que nos tem varios micro serviço separado
nem back end e nem front pode saber todos esse endereço para saber todos esse endereço
para isso usa service discorver, ele vai ter toda instancias endereço de todos micros serviço que tem la


 para fazer isso vamo usar
 Spring cloud Netflix,


   <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>

 para criar pelo spring initilizr


EUREKA SERVE


no application.properties vamos configura tudo nele do service
para tudo no serviço de descoberta recomendado que ele tenha uma porta fixa
server.port=8081



vamos fazer add duas dependecia, por que projeto pode atuar tanto quanto servidor
quanto projeto
mas vamos criar como um server so como isso
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false

como trocou endereço para 8081, tem dizer como vai ser url
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka


server.port=8081

spring.application.name=server
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka


# Configurações de Aplicação
spring.application.name=eureka-server
server.port=8761

# Configurações do Eureka Server
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.server.enable-self-preservation=false
eureka.server.enable-ssl=false

# Configuração Swagger UI (opcional)
springdoc.api-docs.enabled=false
springdoc.swagger-ui.enabled=false
Explicação das Propriedades
spring.application.name=eureka-server: Define o nome da aplicação como "eureka-server".
server.port=8761: Define a porta onde o Eureka Server será acessível.
eureka.client.register-with-eureka=false: Impede que o Eureka Server se registre em si mesmo (não necessário para o Eureka Server).
eureka.client.fetch-registry=false: Impede que o Eureka Server busque o registro de outros serviços (não necessário para o Eureka Server).
eureka.server.enable-self-preservation=false: Desativa a preservação automática para evitar que o Eureka Server se torne inativo.
eureka.server.enable-ssl=false: Desativa SSL para a comunicação do Eureka Server (se SSL não for necessário).
springdoc.api-docs.enabled=false: Desativa a geração de documentação OpenAPI.
springdoc.swagger-ui.enabled=false: Desativa a interface Swagger UI (não necessária para o Eureka Server).




Propriedades
eureka.client.serviceUrl.defaultZone

Propósito: Define o endereço URL do servidor Eureka onde o cliente irá se registrar e buscar informações sobre outros serviços.
Uso: Especifica a URL do servidor Eureka para o cliente Eureka. No caso de múltiplos servidores Eureka, você pode listar várias URLs separadas por vírgulas.
Exemplo: eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.prefer-ip-address

Propósito: Indica se o cliente deve registrar seu IP em vez do nome do host.
Uso: Define se o Eureka Server deve preferir o IP da instância em vez do nome do host ao registrar o serviço. Isso é útil em ambientes onde a resolução de DNS pode não funcionar ou não é desejada.
Exemplo: eureka.instance.prefer-ip-address=true
eureka.instance.hostname

Propósito: Define o nome do host da instância que será registrado no servidor Eureka.
Uso: Define o nome do host que será usado para a instância do serviço ao se registrar no Eureka Server. Se eureka.instance.prefer-ip-address estiver definido como true, isso pode ser ignorado.
Exemplo: eureka.instance.hostname=localhost
-----------------------------------------------------------------------------------------------------------------------
@EnableEurekaServer
isso vc coloca no Application para indicar que vc vai trabalhar com EurekaServer e que é serve



------------------------------------------------------------------------------------------------------------------------------------------
AGORA VC TEM QUE ARRUMAR OUTRO LADO PARA QUE COMUNIQUE COM SERVER, MOSTRA PARA SERVI CLIENTES DELE AS APLICAÇÃO QUE VAI ESTA
PARA MICRO SERVIÇOS
PRIMEIRO DE TUDO VC TEM ADD ESSA DEPENDENCIA

<spring-cloud.version>2022.0.3</spring-cloud.version>

<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
--------------------------------------------------------------------------------------------------------------------------------------------------
QUE NO FINAL FICARA ASSIM

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.3.0</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.Veloxium</groupId>
	<artifactId>Econix</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>Econix</name>
	<description>MS de pagamento da Veloxium</description>
	<properties>
		<java.version>21</java.version>
		<spring-cloud.version>2022.0.3</spring-cloud.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-mysql</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
---------------------------------------------------------------------------------------------------------
E NO APPLICATION NO LADO DO CLIENTE USA ESSA APLICAÇÃO NA CLASS PRINCIPAL DE RODAR
@EnableDiscoveryClient
--------------------------------------------------------------------------------------------------------------------------
AGORA AINDA DO LADO CLIENT, NO APPLICATION.PROPERTIES VAMOS CONFIGURA
PRIMEIRO DE UM NOME
spring.application.name=Econix

DEPOIS A URL DEFAULTZONE POR QUE VAI SER AI QUE VAI RECEBER REQUISUÇÃO
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka
MESMA DO EUREKA

#eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka
#server.port=0
#eureka.instance.prefer-ip-address=true
#eureka.instance.hostname=localhost

POR FIM VAMOS DEIXA EURECA MESMO DECIDIR A PORTA QUE ELE VAI USAR DETE JEITO
server.port=0.
-------------------------------------------------------------------------------------------------------------
 Incluindo o Gateway
 para que serve isso, sere para centralizar serviço e endponit, um ponto unico de entrada de url

"Gateway - Spring Cloud Routing" e "Eureka Discovery Client - Spring Cloud Discovery".

 <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-gateway-mvc</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

CONFIGURAÇÃO
APPLICATION.PROPERTIES

spring.application.name=Gateway
server.port=8082
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka

OQ DE FATO VAI AJUDAR FAZER A DESCOBRERTA FUNCIONAR VAI SER ESSE DOIS COMANDOS

spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true


E ULTIMO É QUE URL VAI TAR TUDO EM LOWERCASE


E NO APPLICATIONS TEM COLOCAR
@EnableDiscoveryClient

como chamar
localhost:8082/nomedomicroserviço/oqvcquerfazerele
ex
http://localhost:8082/gateway/econix/pay
tem usar nome da aplixação gateway




OBS USAR PADRÃO spring-cloud-starter-gateway  -> NA DEPEDENCIA
NÃO O spring-cloud-starter-gateway-MVC QUE ESTA DANDO ERRO
------------------------------------------------------------------------------------------------------------------------------------
BALECEAMENTO DE CARGA

BASTA ADD ISSO
eureka.instance.instance-id=${spring.application.name}:${random.int}
VAI ADD UMA INSTANCIA NOVA
PARA FAZER RODAR OUTRAS RUN BASTA
ADD
& "c:\alura-food\pedidos\mvnw.cmd" spring-boot:run -f "c:\alura-food\pedidos\pom.xml"
NOME QUE TA NA PASTA PMDE ESTA PASSANDO ATE CHAGAR NO POM
CAMINHO QUE ESTA APLICAÇÃO
---------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Feign
para fazer a comunicação de ms para outro micro serviço
primeiro de tudo add essa notação
@EnableFeignClients
no serviço que vc quer vire cliente que que ajuntar com outro micro serviço

e depois essa dependencia
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>



como faz para usar
primeiro cria uma interface que vai usar, por que isso não nada a mais que uma
requisção

e add anotação encima dele de

@FeignClient("")
add nome dele, que é exatamente nome que vc deu para seu micro Serviço


@FeignClient("Econix")


depois request que vc quer fazer


@RequestMapping(method = RequestMethod.PUT, value = "/pay/status/{id}");


passar url que vc quer acessar


E ONDE ULTILIZAR ISSO
na service aonde vc esta ultilizando
ex:
vc faz essa configuração no restaurante para ele ter como pago realizado, e pagamento ms diferente
ai vc vai configura o feign no restaurante e vai ultilizartudo no service do restaurante
ai se chama essa inteface na sua service ou controller, q de resto vai fazer tudo sozinho

e pode retorna coisas caso se precise
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Circuit breaker e fallback

colocando a dependencia
<!-- https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-spring-boot2 -->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <version>2.2.0</version>
</dependency>


e outra


<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
    <version>3.3.0</version>
</dependency>

TUDO ISSO NO CONTROLLER

circuit
serve para quando uma parte do ms esta fora do ar para fechar ele ou tomar a devida descição para colocar ele no ar
novamente etc

oq precisa fazer, no controlador na pasta http

@CircuitBreaker()

de nome para ele
e oq ele vai fazer caso de eerro
@CircuitBreaker(name = "nomeColocado", fallbackMethod = "")

e no applications.properies configura para fazer tal situação

ESSE QUE VAI PASSAR PARA ABERTO OU FECHADO CIRCUIT BASEADO NAS ULTIMAS REQUISIÇÃO
resilience4j.circuitbreaker.instances.nomeColocado.slidingWindowSize: 3

MINIMO DE CHAMADA QUE ELE PRECISA FAZER ATE ENTRA EM FECHAMANETO ETC
resilience4j.circuitbreaker.instances.nomeColocado.minimumNumberOfCalls: 2

UMA VEZ QUE PASSOU PARA ELE PARA ABERTO, QUANTO TEMPO VAI MANTER ABERTO
resilience4j.circuitbreaker.instances.nomeColocado.waitDurationInOpenState: 50s


OQ VAI FAZER SE DEU ERRO
@CircuitBreaker(name = "nomeColocado", fallbackMethod = "OQFAZER")

ESSE METODO TEM TER MESMO NOME MESMO TIPO DE RETORNO, E MESMO PARAMENTROS, E EXCEPRIO E APENA UM PARAMETRO ADD

public void OQFAZER(Long id , Exception e){
this.service -> logica dentro chama sem chamado com integração
}

























Comunicação assíncrona é aquela que não acontece em tempo real. O emissor envia a mensagem e o receptor
pode acessá-la e respondê-la quando desejar. O modelo é mais conveniente para quem recebe, porém requer
objetividade, já que não é possível tirar dúvidas no mesmo momento.




Comunicação síncrona é aquela em que as pessoas interagem em tempo real,
envolvidos na troca simultaneamente. Já na assíncrona, as respostas não são
imediatas, sendo enviadas e recebidas em momentos diferentes


-----------------------------------------------------------------------------------------------------------------------------------

Essas configurações são usadas para habilitar e configurar o SpringDoc OpenAPI no seu aplicativo Spring Boot, permitindo que você acesse a documentação da API e a interface Swagger UI diretamente do seu serviço. Vamos detalhar cada uma:

1. springdoc.api-docs.enabled=true
Objetivo: Esta configuração ativa a geração do documento OpenAPI (Swagger) JSON que descreve a sua API.
Uso: Quando habilitado, o SpringDoc cria um endpoint /v3/api-docs (ou outro configurado) que fornece a especificação OpenAPI em formato JSON. Esse endpoint é usado por ferramentas como Swagger UI para exibir a documentação da API.
2. springdoc.swagger-ui.enabled=true
Objetivo: Esta configuração ativa a interface Swagger UI que permite visualizar e interagir com a documentação da API de forma gráfica.
Uso: Quando habilitado, o SpringDoc disponibiliza o Swagger UI na URL configurada, permitindo que você visualize a documentação da sua API e teste os endpoints diretamente a partir do navegador.
3. springdoc.swagger-ui.path=/swagger-ui.html
Objetivo: Define o caminho onde a interface Swagger UI estará disponível.
Uso: Por padrão, o Swagger UI é acessível através de /swagger-ui.html. Se você quiser configurar um caminho diferente para o Swagger UI, pode ajustar esta propriedade.
Exemplo de Configuração Completa em application.properties
Aqui está como essas configurações podem ser adicionadas ao seu application.properties para habilitar o Swagger UI e a documentação OpenAPI no seu serviço:

properties
Copiar código
# Habilitar a geração do documento OpenAPI
springdoc.api-docs.enabled=true

# Habilitar a interface Swagger UI
springdoc.swagger-ui.enabled=true

# Caminho para acessar a Swagger UI
springdoc.swagger-ui.path=/swagger-ui.html





package br.com.Gateway;

import org.springdoc.core.models.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration

public class GatewaySwaggerConfig {
    @Bean
    public GroupedOpenApi employeeServiceApi() {
        return GroupedOpenApi.builder()
                .group("employee-service")
                .pathsToMatch("/employee/**")
                .build();
    }
}
	<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
			<version>2.5.0</version>
		</dependency>

----------------------------------------------------
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
para que serve

O ChatGPT disse:
ChatGPT
As propriedades eureka.client.register-with-eureka e eureka.client.fetch-registry são usadas para configurar como um cliente Spring Cloud (como um microserviço ou gateway) interage com o Eureka Server para o serviço de descoberta. Vamos detalhar o propósito de cada uma delas:

1. eureka.client.register-with-eureka=true
Propósito:
Essa propriedade indica se o cliente (por exemplo, um microserviço ou gateway) deve se registrar no Eureka Server como um serviço.

Quando configurado como true: O cliente se registra no Eureka Server, o que significa que ele informa ao Eureka Server que está disponível e pronto para receber solicitações. Isso é útil para outros serviços que possam precisar descobrir e se comunicar com ele.

Quando configurado como false: O cliente não se registra no Eureka Server. Isso é útil em situações onde o serviço está apenas consumindo informações de outros serviços e não precisa ser descoberto.

Exemplo de Uso:
No caso de um API Gateway ou um microserviço, você normalmente deseja que ele se registre no Eureka Server para que outros serviços possam descobrir e se comunicar com ele.

2. eureka.client.fetch-registry=true
Propósito:
Essa propriedade define se o cliente deve buscar (fazer fetch) do registro de serviços do Eureka Server. O registro de serviços é uma lista de todos os serviços atualmente registrados no Eureka Server.

Quando configurado como true: O cliente busca o registro de serviços do Eureka Server, permitindo que ele descubra e se comunique com outros serviços registrados. Isso é essencial para microserviços que precisam interagir uns com os outros ou para um gateway que precisa rotear solicitações para os serviços backend.

Quando configurado como false: O cliente não busca o registro de serviços. Isso é útil para situações onde o serviço não precisa descobrir outros serviços, como quando um serviço está sendo usado apenas para administração ou monitoramento.

Exemplo de Uso:
Para um API Gateway, fetch-registry deve ser true para que ele possa descobrir e rotear solicitações para outros microserviços registrados no Eureka Server.

Resumo
eureka.client.register-with-eureka=true: Registra o cliente no Eureka Server para que outros serviços possam descobri-lo.
eureka.client.fetch-registry=true: Permite que o cliente busque o registro de serviços do Eureka Server para descobrir outros serviços.
Em um ambiente típico de microserviços usando Spring Cloud Netflix Eureka, você geralmente configura ambos como true para permitir a descoberta mútua e a comunicação entre os serviços.

-----------------------------------------------
A configuração que você forneceu para o Gateway em um ambiente de microserviços com Spring Cloud Gateway e Eureka é bastante detalhada e cobre várias áreas importantes. Vamos analisar cada parte para entender o que faz:

1. Configurações de Aplicação
properties
Copiar código
spring.application.name=gateway
server.port=8082
spring.application.name: Define o nome do aplicativo, neste caso, "gateway". Esse nome é utilizado no registro do serviço com o Eureka e para identificação geral do serviço.
server.port: Define a porta na qual o gateway estará ouvindo. Aqui, ele está configurado para ouvir na porta 8082.
2. Configurações do Eureka Client
properties
Copiar código
eureka.client.serviceUrl.defaultZone=http://localhost:8081/eureka
eureka.instance.prefer-ip-address=true
eureka.instance.hostname=localhost
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.serviceUrl.defaultZone: Configura a URL do servidor Eureka onde o cliente deve se registrar. Aqui, está configurado para um servidor Eureka em execução localmente na porta 8081.

eureka.instance.prefer-ip-address=true: Quando definido como true, isso faz com que o serviço prefira usar seu endereço IP em vez do nome do host ao se registrar no Eureka. Isso é útil em ambientes onde o DNS pode não estar configurado corretamente.

eureka.instance.hostname=localhost: Define o hostname da instância. Para ambientes locais, isso é frequentemente configurado como localhost.

eureka.client.register-with-eureka=true: Informa ao cliente Eureka para registrar o próprio gateway no servidor Eureka para que outros serviços possam descobri-lo.

eureka.client.fetch-registry=true: Configura o cliente para buscar o registro de outros serviços do servidor Eureka, permitindo que o gateway descubra outros serviços registrados.

3. Configurações do Gateway para os Microserviços
properties
Copiar código
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true
spring.cloud.gateway.discovery.locator.enabled=true: Ativa o Discovery Locator, permitindo que o gateway automaticamente configure rotas para todos os serviços registrados no Eureka. Isso simplifica muito a configuração do gateway, pois as rotas são automaticamente criadas com base nos serviços descobertos.

spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true: Faz com que todos os IDs dos serviços sejam convertidos para minúsculas. Isso é útil para evitar problemas de correspondência de caso sensível em ambientes onde os IDs de serviço podem não ser consistentes.

4. Configurações de Swagger e OpenAPI
properties
Copiar código
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.enabled=true: Habilita a geração de documentação OpenAPI para o serviço, essencial para fornecer informações sobre os endpoints disponíveis.

springdoc.swagger-ui.enabled=true: Ativa a interface Swagger UI, que é uma ferramenta interativa para explorar e testar APIs RESTful.

springdoc.swagger-ui.path=/swagger-ui.html: Define o caminho onde o Swagger UI estará acessível no gateway, neste caso, /swagger-ui.html.

5. Rotas para Microserviços
As rotas são configuradas para que o gateway saiba como rotear solicitações para os diferentes microserviços. Aqui está a configuração para o Employee Service:

properties
Copiar código
# Employee Service
spring.cloud.gateway.routes[0].id=employee-service
spring.cloud.gateway.routes[0].uri=lb://employee
spring.cloud.gateway.routes[0].predicates[0]=Path=/employee/**, /v3/api-docs/employee-service/**, /swagger-ui/**, /swagger-ui.html
spring.cloud.gateway.routes[0].filters[0]=RewritePath=/v3/api-docs/employee-service(?<segment>.*), /v3/api-docs${segment}
spring.cloud.gateway.routes[0].filters[1]=RewritePath=/swagger-ui(?<segment>.*), /swagger-ui${segment}
spring.cloud.gateway.routes[0].filters[2]=RewritePath=/swagger-ui.html(?<segment>.*), /swagger-ui.html${segment}
spring.cloud.gateway.routes[0].id=employee-service: Define o identificador único para a rota. Neste caso, o identificador é "employee-service".

spring.cloud.gateway.routes[0].uri=lb://employee: Define o URI de destino usando o esquema lb://, que indica ao gateway para usar o balanceamento de carga (load balancing) através do Eureka para o serviço "employee". Isso significa que todas as requisições que correspondam aos padrões abaixo serão roteadas para o serviço de empregado (employee).

spring.cloud.gateway.routes[0].predicates[0]=Path=/employee/**, /v3/api-docs/employee-service/**, /swagger-ui/**, /swagger-ui.html: Define os predicados da rota, ou seja, as condições que as solicitações devem atender para serem roteadas por esta rota. Aqui, todas as requisições para caminhos que começam com /employee/**, /v3/api-docs/employee-service/**, /swagger-ui/** ou /swagger-ui.html serão roteadas para o serviço "employee".

spring.cloud.gateway.routes[0].filters: Define filtros de rota. Neste exemplo, os filtros RewritePath são usados para reescrever o caminho das URLs da documentação OpenAPI e Swagger UI:

spring.cloud.gateway.routes[0].filters[0]=RewritePath=/v3/api-docs/employee-service(?<segment>.*), /v3/api-docs${segment}: Este filtro reescreve a rota /v3/api-docs/employee-service para /v3/api-docs, mantendo o segmento subsequente. Isso permite que a documentação OpenAPI do serviço "employee" seja corretamente exibida no Swagger UI do gateway.

spring.cloud.gateway.routes[0].filters[1] e spring.cloud.gateway.routes[0].filters[2]: De forma similar, esses filtros reescrevem as rotas relacionadas ao Swagger UI para garantir que a interface do Swagger seja corretamente exibida quando acessada através do gateway.

Resumo
Eureka Client: Registra o gateway com o servidor Eureka e permite que ele descubra outros serviços.
Discovery Locator: Automatiza a criação de rotas no gateway para serviços descobertos.
Swagger/OpenAPI: Ativa e configura a documentação interativa das APIs.
Rotas de Gateway: Define como as requisições devem ser roteadas do gateway para os microserviços, incluindo reescrita de caminhos para compatibilidade com documentação OpenAPI.
Essas configurações permitem que o gateway funcione como um ponto central de entrada para sua arquitetura de microserviços, roteando solicitações e fornecendo documentação API integrada para os serviços backend.

------------------------------------------------

Se você deseja saber qual endereço usar para acessar um serviço ou recurso específico, aqui estão alguns pontos para ajudar a determinar o endereço correto:

Serviço Eureka:

O Eureka é um serviço de descoberta de serviços, e seu endereço é definido na configuração dos clientes e do próprio servidor. No exemplo que você forneceu:
O servidor Eureka está configurado para ser acessado em http://localhost:8081/eureka.
Serviço Gateway:

O Gateway é um ponto de entrada para os microserviços e deve ser acessado na porta onde ele está configurado para rodar. Com base nas configurações:
O Gateway está configurado para rodar em http://localhost:8082.
Serviços Registrados no Eureka:

Serviços como "employee-service" e "house-service" são registrados no Eureka e podem ser acessados via Gateway. O endereço será através do Gateway, que por sua vez consulta o Eureka para resolver o serviço.
Por exemplo, para acessar o serviço "employee-service" através do Gateway, você pode usar:
http://localhost:8082/employee/
Swagger UI:

Para acessar a interface do Swagger UI através do Gateway, você pode usar:
http://localhost:8082/swagger-ui.html
Documentação API (OpenAPI):

As rotas configuradas para acessar a documentação OpenAPI dos serviços via Gateway dependem dos filtros e reescritas configuradas. Por exemplo:
Para acessar a documentação do "employee-service" via Gateway, você pode usar:
http://localhost:8082/v3/api-docs/employee-service
Como Verificar os Endereços Usados:
Para confirmar qual endereço está sendo usado ou deve ser usado, verifique os seguintes pontos:

Configurações no arquivo application.properties ou application.yml: Verifique as configurações de server.port, eureka.client.serviceUrl.defaultZone, e rotas do Spring Cloud Gateway.
Servidor Eureka Dashboard: Acesse o painel de controle do Eureka em http://localhost:8081 para ver quais serviços estão registrados e em quais endereços.
Logs de inicialização do aplicativo: Ao iniciar o servidor ou os serviços, os logs geralmente mostram em quais portas eles estão ouvindo e os endereços configurados.
Se você estiver tendo problemas para acessar um serviço, certifique-se de que ele está em execução e que a configuração do serviço, incluindo portas e endereços IP, está correta.



As propriedades eureka.server.enable-self-preservation e eureka.server.enable-ssl são usadas para configurar o comportamento do Eureka Server em termos de preservação de instâncias e segurança. Aqui está uma explicação detalhada para cada uma:

eureka.server.enable-self-preservation
Descrição: Habilita ou desabilita o modo de preservação automática do Eureka Server.
Valor:
true (padrão): O Eureka Server está em modo de preservação automática, o que significa que ele tenta proteger instâncias registradas de serem removidas por engano, mesmo que não tenham se registrado recentemente. Isso é feito para evitar a remoção de instâncias que podem estar temporariamente fora do ar.
false: Desativa o modo de preservação automática, permitindo que o Eureka Server remova instâncias que não têm feito o "heartbeat" recentemente, mesmo que isso possa levar à remoção de instâncias que podem estar fora do ar temporariamente.
Uso Típico: O modo de preservação automática é útil em ambientes de produção onde a instabilidade temporária pode ocorrer e você não quer que o Eureka Server remova instâncias devido a uma breve perda de conectividade.

Quando Desativar: Pode ser desativado para testes ou em ambientes onde você sabe que todas as instâncias estarão sempre ativas e responsivas. Desativar pode ajudar a depurar problemas com instâncias que não estão se registrando corretamente.

eureka.server.enable-ssl
Descrição: Habilita ou desabilita a criptografia SSL para comunicação com o Eureka Server.
Valor:
true: Ativa a criptografia SSL para todas as comunicações com o Eureka Server. Isso ajuda a garantir que as comunicações entre clientes e o servidor sejam seguras.
false (padrão): Desativa a criptografia SSL, o que significa que a comunicação com o Eureka Server será feita em texto simples.
Uso Típico: Habilitar SSL é recomendado para ambientes de produção para garantir que os dados transmitidos entre clientes e o Eureka Server sejam criptografados e seguros.

Quando Desativar: Pode ser desativado em ambientes de desenvolvimento ou teste onde a segurança não é uma preocupação imediata, mas isso não é recomendado para ambientes de produção.

Exemplo de Configuração
Se você quiser usar SSL e permitir a preservação automática, você pode configurar o Eureka Server da seguinte forma:

properties
Copiar código
eureka.server.enable-self-preservation=true
eureka.server.enable-ssl=true
Se, por outro lado, você está em um ambiente de teste e quer desativar a preservação automática e o SSL, pode configurá-lo assim:

properties
Copiar código
eureka.server.enable-self-preservation=false
eureka.server.enable-ssl=false
Estas configurações devem ser ajustadas conforme as necessidades de segurança e estabilidade do seu ambiente de deployment.



--------------------------------------------------------------------------
Parece que você está tentando configurar rotas no Spring Cloud Gateway usando uma abordagem com RouterFunction e HandlerFunctions. Se você deseja passar de um modelo com RouterFunction para o modelo sem MVC, você deve garantir que o código esteja configurado corretamente para o Spring Cloud Gateway usando o Spring WebFlux, e não o Spring MVC.

Ajustando o Código para Spring Cloud Gateway
No Spring Cloud Gateway, você deve usar a abordagem reativa fornecida pelo WebFlux. Em vez de usar RouterFunction e HandlerFunctions, você pode configurar as rotas diretamente no arquivo application.yml ou application.properties ou usar o RouteLocator programaticamente para definir as rotas.

Aqui estão os exemplos para ambas as abordagens:

1. Configuração no application.yml
Se você quiser configurar suas rotas diretamente no arquivo de configuração, você pode usar o application.yml como segue:

yaml
Copiar código
spring:
  cloud:
    gateway:
      routes:
        - id: employee_service
          uri: http://localhost:8083
          predicates:
            - Path=/api/employee/**
        - id: employee_service_swagger
          uri: http://localhost:8083
          predicates:
            - Path=/aggregate/employee-service/v3/api-docs
          filters:
            - RewritePath=/aggregate/employee-service/(?<segment>.*), /${segment}
Explicação:

id: Identificador único para a rota.
uri: O URI de destino para onde a requisição será encaminhada.
predicates: Condições para a correspondência das requisições.
filters: Filtros aplicados à requisição antes de encaminhá-la.
2. Configuração Programática com RouteLocator
Se você preferir configurar as rotas programaticamente, use a classe RouteLocator:

java
Copiar código
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("employee_service", r -> r
                        .path("/api/employee/**")
                        .uri("http://localhost:8083"))
                .route("employee_service_swagger", r -> r
                        .path("/aggregate/employee-service/v3/api-docs")
                        .filters(f -> f.rewritePath("/aggregate/employee-service/(?<segment>.*)", "/${segment}"))
                        .uri("http://localhost:8083"))
                .build();
    }
}
Explicação:

route: Define uma nova rota.
path: Predicado para corresponder o caminho da URL.
filters: Aplicar filtros, como reescrever o caminho.
uri: O URI de destino para onde a requisição será encaminhada.
Comparação e Escolha
Configuração no application.yml: Mais simples e adequada para configurações básicas e rápidas. Preferida quando as rotas são fixas e não requerem lógica programática complexa.
Configuração com RouteLocator: Oferece maior flexibilidade e permite lógica programática complexa. Preferida quando as rotas são dinâmicas ou precisam de processamento adicional.
Conclusão
Se você está migrando de uma configuração baseada em RouterFunction para um modelo sem MVC (e usando Spring Cloud Gateway), a configuração no application.yml ou RouteLocator programaticamente é a abordagem recomendada. Ambas as abordagens garantem que suas rotas sejam configuradas de acordo com o modelo reativo do Spring WebFlux, sem a necessidade do modelo MVC.







Você disse:
estoiu usando proprites
O ChatGPT disse:
ChatGPT
Memória atualizada
Se você está configurando o Spring Cloud Gateway usando application.properties, aqui está como você pode traduzir a configuração que você tem em application.yml para o formato de propriedades.

Configuração com application.properties
Para configurar as rotas no application.properties, você deve usar a mesma lógica de configuração que seria aplicada no application.yml, mas com a sintaxe de propriedades. Aqui está como você pode fazer isso:

properties
Copiar código
# Configuração da rota para o serviço de funcionários
spring.cloud.gateway.routes[0].id=employee_service
spring.cloud.gateway.routes[0].uri=http://localhost:8083
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/employee/**

# Configuração da rota para a documentação Swagger do serviço de funcionários
spring.cloud.gateway.routes[1].id=employee_service_swagger
spring.cloud.gateway.routes[1].uri=http://localhost:8083
spring.cloud.gateway.routes[1].predicates[0]=Path=/aggregate/employee-service/v3/api-docs
spring.cloud.gateway.routes[1].filters[0]=RewritePath=/aggregate/employee-service/(?<segment>.*), /${segment}
Explicação das Propriedades
spring.cloud.gateway.routes[n].id: Identificador único para a rota. O índice n deve ser único para cada rota (começa em 0, 1, 2, ...).
spring.cloud.gateway.routes[n].uri: O URI de destino para onde a requisição será encaminhada.
spring.cloud.gateway.routes[n].predicates[m]: Predicados usados para corresponder o caminho da URL. O índice m é para múltiplos predicados, se necessário.
spring.cloud.gateway.routes[n].filters[m]: Filtros aplicados à requisição antes de encaminhá-la. O índice m é para múltiplos filtros, se necessário.
Exemplo Completo
Aqui está um exemplo completo para application.properties com duas rotas configuradas:

properties
Copiar código
# Primeira rota
spring.cloud.gateway.routes[0].id=employee_service
spring.cloud.gateway.routes[0].uri=http://localhost:8083
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/employee/**

# Segunda rota
spring.cloud.gateway.routes[1].id=employee_service_swagger
spring.cloud.gateway.routes[1].uri=http://localhost:8083
spring.cloud.gateway.routes[1].predicates[0]=Path=/aggregate/employee-service/v3/api-docs
spring.cloud.gateway.routes[1].filters[0]=RewritePath=/aggregate/employee-service/(?<segment>.*), /${segment}
Considerações
Indices de Rota e Filtro: Certifique-se de que cada rota e filtro tem um índice único e incremental.
Reescrita de Caminho: A propriedade RewritePath usa uma expressão regular para reescrever o caminho da URL conforme necessário.
Certifique-se de que o Spring Cloud Gateway está configurado corretamente para carregar essas propriedades e que o serviço de destino está acessível na URL especificada.






Você disse:
spring.cloud.gateway.routes[1].filters[0]=RewritePath=/aggregate/employee-service/(?<segment>.*), /${segment}
explica melhotra esse
O ChatGPT disse:
ChatGPT
Claro! A configuração RewritePath em um filtro no Spring Cloud Gateway é usada para modificar o caminho da URL de uma requisição antes de encaminhá-la para o serviço de destino. Vamos detalhar a expressão RewritePath=/aggregate/employee-service/(?<segment>.*), /${segment} para entender como ela funciona:

Estrutura do RewritePath
A sintaxe para o filtro RewritePath é:

properties
Copiar código
RewritePath=<regex>, <replacement>
<regex>: A expressão regular que será usada para capturar partes da URL.
<replacement>: O modelo de substituição que será aplicado à URL capturada.
Explicação da Configuração
Configuração:

properties
Copiar código
spring.cloud.gateway.routes[1].filters[0]=RewritePath=/aggregate/employee-service/(?<segment>.*), /${segment}
/aggregate/employee-service/(?<segment>.*):
/aggregate/employee-service/: Esta é a parte do caminho da URL que você quer capturar e substituir.
(?<segment>.*): Aqui, (?<segment>.*) é uma expressão regular com um grupo nomeado chamado segment. O .* captura qualquer sequência de caracteres que venha após /aggregate/employee-service/ na URL.
(?<segment> ...): Define um grupo nomeado na expressão regular. O nome do grupo é segment, e .* captura tudo o que vem depois do prefixo /aggregate/employee-service/.
/${segment}:
/${segment}: Esta é a parte de substituição. ${segment} será substituído pelo valor capturado pelo grupo nomeado segment na expressão regular.
O ${segment} refere-se ao valor que foi capturado pelo grupo segment e o coloca diretamente no caminho de destino.
Exemplo Prático
Vamos considerar um exemplo para ilustrar como essa reescrita funciona.

URL Original: http://localhost:8080/aggregate/employee-service/v3/api-docs
Expressão Regular: /aggregate/employee-service/(?<segment>.*)
Captura: v3/api-docs será capturado pelo grupo nomeado segment.
Após a Reescrita:

Caminho de Substituição: /v3/api-docs
O caminho /aggregate/employee-service/ é removido e v3/api-docs é preservado.
URL Reescrita Final:

Para o Serviço de Destino: http://localhost:8083/v3/api-docs
Resumo
Objetivo do RewritePath: Modificar o caminho da URL da requisição antes de encaminhá-la para o serviço de destino.
Expressão Regular: Captura a parte relevante da URL.
Substituição: Usa o valor capturado para formar o novo caminho de URL.
A reescrita de caminho é útil quando você precisa ajustar o caminho das requisições para se adequar à estrutura esperada pelo serviço de destino, especialmente quando a URL pública e a URL interna para o serviço diferem.








---------------------------------------------------------------------------COMO CENTRALIZAR A DOCUMENTAÇÃO
-------------AQUI AS CONFIG BASICA DOS MICRO SERVIÇO

# Server Port Settings
server.port=8083

# Swagger and OpenAPI Settings
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html

# Server Context Settings
server.servlet.context-path=/

-------------------CONFIG DO GATEWAY
#Swagger and OpenAPI Settings
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.enable-native-support=true
springdoc.swagger-ui.config-url=/v3/api-docs/swagger-config

#Swagger UI URLs
springdoc.swagger-ui.urls[0].url=/v3/api-docs
springdoc.swagger-ui.urls[0].name=service gateway API

----------AQUI CONFIGURA AS URL DO MICROSERVIÇO
springdoc.swagger-ui.urls[1].url=/aggregate/employee-service/v3/api-docs
springdoc.swagger-ui.urls[1].name=service employee


AQUI CRIA UMA CLASS COM
 @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("employee_service", r -> r
                        .path("/api/employee/**")
                        .uri("http://localhost:8083"))//Microservice running on port 8083
                .route("employee_service_swagger", r -> r
                        .path("/aggregate/employee-service/v3/api-docs")
                        .filters(f -> f.rewritePath("/aggregate/employee-service/(?<segment>.*)", "/${segment}"))
                        .uri("http://localhost:8083")) //Route to Swagger JSON
                .route("swagger_ui", r -> r
                        .path("/swagger-ui/**")
                        .filters(f -> f.rewritePath("/swagger-ui/(?<segment>.*)", "/${segment}"))
                        .uri("http://localhost:8083")) //Route to Swagger UI
-------------------PARA CONFIGURA AS URLS E QUEM PODE ACESSAR


https://spring.io/ TODA DOCUMENTAÇÕES DO SPRING BOOT